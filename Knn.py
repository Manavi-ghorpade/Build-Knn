# -*- coding: utf-8 -*-
"""Welcome To Colaboratory

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

import numpy as np
import statistics

def quicksort(matrix,a) :
    if len(matrix) == 0:
        return []
    else:
        pivot = matrix[0]
        lesser_numbers = quicksort([x for x in matrix[1:] if x[a] < pivot[a]], a)
        greater_numbers = quicksort([x for x in matrix[1:] if x[a] >= pivot[a]],a)
        return lesser_numbers + [pivot] + greater_numbers
def euclidean_distance(a,b):
    a1=np.array(a)
    b1=np.array(b)
    d=np.sqrt(np.sum(np.square(a1-b1)))
    return d
def minkowski (a, b, p=2):
    # equ_part1 = ∑i=1:n |Xi − Yi|^p
    part1= np.sum(np.power(np.abs(a - b), p))
    # distance = (equ_part1)^1/p
    d = np.power(part1, 1 / p)
    return np.round(d, 3)
def manhattan_distance(a, b):
    return sum(abs(a - b))

def knnBuild(model,k,algo="euclidean",p=2):
  knn=KNN(model,k,algo,p)
  return knn

class KNN:
    def __init__(self,model, k, algorithm="euclidean",p=2):
      self.model=model
      self.k=k
      self.algorithm=algorithm
      self.p=p
      self.X_train=0
      self.y_train=0
    def knnFit(self,X_train,y_train):
      self.X_train=X_train
      self.y_train=y_train
    def knn_label(self,row,d):
      distance=[]
      for i in self.X_train:
          if(self.algorithm=="euclidean"):
            dist=euclidean_distance(row,i)
            distance.append(dist)
          elif(self.algorithm=="minkowski"):
            dist=minkowski(row,i,self.p)
            distance.append(dist)
          elif(self.algorithm=="manhattan"):
            dist=manhattan_distance(row,i)
            distance.append(dist)
      arr1=np.array(distance)
      arr2=np.arange(d)
      arr3=np.column_stack((arr2,arr1)) 
      arr3=quicksort(arr3, 1)
      indices=[]
      c=0
      if (self.k==1):
        indices.append(arr3[0][0])
      else: 
        for i in arr3:
             if(c==self.k):
               break
             indices.append(i[0])
             c+=1 
      labels=[]
      for j in indices:
           labels.append(self.y_train[int(j)])
      if(self.model=="regression"):
        return sum(labels) / len(labels)
      else:
       return statistics.mode(labels)
    def knnPredict(self,test):
      predictions = []
      d=(self.X_train.shape)[0]
      test=np.array(test)
      if(test.ndim==1):
        label = self.knn_label(test,d)
        predictions.append(label)
      else:
        for i in test:
          label =(self.knn_label(i,d))
          predictions.append(label)
      return predictions